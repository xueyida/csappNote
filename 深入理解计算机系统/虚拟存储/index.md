### 春风2



#### 6.2.1

早期管理员，自己管理主存；

程序员需要做分配管理，某个阶段把程序从内存中调出，哪个阶段调出；哪个阶段需要重新分配，以免写到其他内存中去；


第一步：
    实现一种管理内存的工具：
        思路：把地址空间与主存区分开；编程序的时候使用地址空间，真正使用的时候使用内存；该工具的作用就是把地址空间映射到内存上去；
    现在：
        这个工具就是早期的分页管理机制；
    
    
    举例：早期分页存储方式


#### 6.2.2

现代虚拟存储方式

1. 把主存分成较小的（ 页框）
2. 每个进程也被划分成固定长的程序快（页）
3. 页通过映射可以存到主存中去
4.页跟页框是一一对应的


操作系统为每个进程生成一个页表（表一般是一个数组）；（哪个极端生成）

需要再听


#### 6.3.1

    
    

**1.20min有些不明白....????????????**

每个进程有一个页表，对地址空间在内存中的位置进行描述

页表反应了数据在磁盘还是内存中的位置？还是有些不明白。。。。



1. 程序执行时，把需要的程序段和相应的数据块存入主存，其他放在磁盘上了

    *这里是怎么从硬盘中取数据的，如何取，先取哪一部分。。。。*


2. cpu读到指令，然后再进行地址转换，地址转换由硬件来做；

    *执行指令时，根据程序的页表进行查找；*


#### 6.3.2

1. 虚拟地址空间中的各个数据段：

0x00000000  内核空间

            用户栈 （从上往下增长，从低地址往高地址增长）

            共享库 （从下往上）

            堆 （从下往上）
            
            可读可写数据

            只读数据
            
            代码

0x08048000


2. 加载可执行文件执行时，不会把代码或者数据放到内存中；
    
    而是生成初始的页表，页表的内容是什么；
    
    什么时候加载到主存按需调页；按需调页是由page fault 异常实现的

#### 6.4.2

- 如何实现虚拟存储管理？

问题：
页有多大？
主存与硬盘的空间如何管理？主存与硬盘如何替换？
程序快如何与虚拟存储器进行映射
逻辑地址和物理地址如何转换？（也就是虚拟地址跟物理地址如何转换）转换速度如何提高？
页表如何实现？


- 有三种虚拟存储器实现方式：
分页 分段 段页


- 页大小 2kB~64kB

    缺页时需要访问磁盘；比较慢，需要几百万个时钟周期；页大一些，可以减少缺页的概率；

- 全相连

- 缺页用软件完成
    缺页要访问磁盘，太慢了，不能用硬件实现？  **这里不是很懂，如何用硬件访问磁盘，如何用软件访问磁盘，两者的区别是什么？什么是硬件实现？** 

    目前理解硬件实现是，有专门的硬件电路去处理；不需要转换，比如通过操作系统；

- 什么是write back,
    只写主存，不写磁盘，叫做write back;

- 地址访问用硬件实现   


#### 6.4.2

1.  页表的格式：

    装入位         修改位        替换控制位                          其他        实页号
     
    0/1                          使用情况，是否被替换出去           访问权限       11
   
    不在/在主存
    

2. 虚拟地址空间/每页（煤业通常是4kB）  

    通常有1M (2^20)个页

    一个表项 占4个字节或者8个字节，32位或64位

    页表还要分页是什么鬼？。。。。


3. 页表存在虚拟内存的内核区


4. 主存中的页表是什么鬼？对可执行文件的实现吗


#### 6.4.3

虚拟页表             ->实页表                                      ->物理存储位置

可执行文件已经生成    页表位于内存中，可执行文件执行时生成实业表         具体的物理地址                

va - a - pa

虚拟页表转换为实页表的公式？


实页表转换为地址的公式？

根据实页表中的一个字段判断是否在内存中是否存在，判断是否缺页

虚拟转换中的两种问题：

1. 缺页

2. 访问违例


#### 6.4.4

**需要重新看的,感觉还是一个比较重要的阶段**

快表

跟实页表是不一样的


页表放在主存


快表是把页表放在缓存中

全相联与组相连



#### 6.5.1

整个存储的访问过程的总结


#### 6.6.1

    段式与段页式的介绍，基本思路跟分页差不多；
















